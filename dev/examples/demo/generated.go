// The demo command was automatically generated by Shenzhen Go.
package main

import (
	"fmt"
	"sync"
)

func Node_1(bar <-chan rune, baz chan<- float64, foo <-chan int, quux chan<- string, qux chan<- int, tuz <-chan int64) {

	func(instanceNumber, multiplicity int) {
		fmt.Println("Node 1: Started.")
		fmt.Println("Node 1: Now closing qux...")
		close(qux)
		fmt.Println("Node 1: Finished.")
	}(0, 1)

}

func Node_2(bar <-chan rune, baz chan<- float64, foo <-chan int, quux chan<- string, qux chan<- int, tuz <-chan int64) {

	func(instanceNumber, multiplicity int) {
		fmt.Println("Node 2: Started.")
		fmt.Println("Node 2: Waiting on foo...")
		<-foo
		fmt.Println("Node 2: Finished.")
	}(0, 1)

}

func main() {

	channel0 := make(chan int, 0)

	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		Node_1(nil, nil, nil, nil, channel0, nil)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Node_2(nil, nil, channel0, nil, nil, nil)
		wg.Done()
	}()

	// Wait for the end
	wg.Wait()
}
