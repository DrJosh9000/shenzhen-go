// The cache command was automatically generated by Shenzhen Go.
package main

import (
	"fmt"
	"math/rand"
	"runtime"
	"sync"
	"time"
)

var _ = runtime.Compiler

func Cache(get <-chan int, hit chan<- struct {
	Key  int
	Data []byte
}, miss chan<- int, put <-chan struct {
	Key  int
	Data []byte
}) {
	multiplicity := runtime.NumCPU()

	const bytesLimit = 1073741824
	type cacheEntry struct {
		data []byte
		last time.Time
		sync.Mutex
	}
	var mu sync.RWMutex
	totalBytes := uint64(0)
	cache := make(map[int]*cacheEntry)

	defer func() {
		close(hit)
		close(miss)
	}()
	var multWG sync.WaitGroup
	multWG.Add(multiplicity)
	defer multWG.Wait()
	for n := 0; n < multiplicity; n++ {
		go func() {
			defer multWG.Done()

			for {
				if get == nil && put == nil {
					break
				}
				select {
				case g, open := <-get:
					if !open {
						get = nil
						continue
					}
					mu.RLock()
					e, ok := cache[g]
					mu.RUnlock()
					if !ok {
						miss <- g
						continue
					}
					e.Lock()
					hit <- struct {
						Key  int
						Data []byte
					}{
						Key:  g,
						Data: e.data,
					}
					e.last = time.Now()
					e.Unlock()

				case p, open := <-put:
					if !open {
						put = nil
						continue
					}
					if len(p.Data) > bytesLimit {
						// TODO: some kind of failure message
						continue
					}

					// TODO: Can improve eviction algorithm - this is simplistic but O(n^2)
					mu.Lock()
					for {
						// Find something to evict if needed.
						var ek int
						var ee *cacheEntry
						et := time.Now()
						for k, e := range cache {
							e.Lock()
							if e.last.Before(et) {
								ee, et, ek = e, e.last, k
							}
							e.Unlock()
						}
						// Necessary to evict?
						if totalBytes+uint64(len(p.Data)) > bytesLimit {
							// Evict ek.
							if ee == nil {
								// TODO: some kind of error message
								break
							}
							ee.Lock()
							totalBytes -= uint64(len(ee.data))
							ee.Unlock()
							delete(cache, ek)
							continue
						}

						// No - insert now.
						cache[p.Key] = &cacheEntry{
							data: p.Data,
							last: time.Now(),
						}
						totalBytes += uint64(len(p.Data))
						break
					}
					mu.Unlock()
				}
			}
		}()
	}
}

func Get_random_items(keys chan<- int) {

	defer func() {
		close(keys)
	}()
	for i := 0; i < 200; i++ {
		keys <- rand.Intn(6)
	}
}

func Print_hits(gets <-chan struct {
	Key  int
	Data []byte
}) {

	for g := range gets {
		fmt.Printf("Hit: %v (size %v)\n", g.Key, len(g.Data))
	}
}

func Print_misses(keys <-chan int) {

	for k := range keys {
		fmt.Printf("Miss: %v\n", k)
	}
}

func Put_random_sizes(puts chan<- struct {
	Key  int
	Data []byte
}) {

	defer func() {
		close(puts)
	}()
	for i := 0; i < 6; i++ {
		puts <- struct {
			Key  int
			Data []byte
		}{
			Key: i,
			// Very large sizes to trigger evictions
			Data: make([]byte, rand.Intn(1<<29)),
		}
	}
}

func main() {

	channel0 := make(chan int, 0)
	channel1 := make(chan struct {
		Key  int
		Data []byte
	}, 0)
	channel2 := make(chan int, 0)
	channel3 := make(chan struct {
		Key  int
		Data []byte
	}, 0)

	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		Cache(channel0, channel3, channel2, channel1)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Get_random_items(channel0)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Print_hits(channel3)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Print_misses(channel2)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Put_random_sizes(channel1)
		wg.Done()
	}()

	// Wait for the various goroutines to finish.
	wg.Wait()
}
