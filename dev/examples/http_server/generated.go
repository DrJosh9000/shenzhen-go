// The http_server command was automatically generated by Shenzhen Go.
package main

import (
	"context"
	"fmt"
	"github.com/google/shenzhen-go/dev/parts"
	"log"
	"net/http"
	"sync"

	"github.com/prometheus/client_golang/prometheus/promhttp"
	"time"
)

func HTTPServeMux(metrics chan<- *parts.HTTPRequest, requests <-chan *parts.HTTPRequest, root chan<- *parts.HTTPRequest) {
	const multiplicity = 1
	mux := http.NewServeMux()
	mux.Handle("/", parts.HTTPHandler(root))
	mux.Handle("/metrics", parts.HTTPHandler(metrics))

	defer func() {
		close(root)
		close(metrics)

	}()
	const instanceNumber = 0
	for req := range requests {
		// Borrow fix for Go issues #3692 and #5955.
		if req.Request.RequestURI == "*" {
			if req.Request.ProtoAtLeast(1, 1) {
				req.ResponseWriter.Header().Set("Connection", "close")
			}
			req.ResponseWriter.WriteHeader(http.StatusBadRequest)
			req.Close()
			continue
		}
		h, _ := mux.Handler(req.Request)
		hh, ok := h.(parts.HTTPHandler)
		if !ok {
			// ServeMux may return handlers that weren't added above.
			h.ServeHTTP(req.ResponseWriter, req.Request)
			req.Close()
			continue
		}
		hh <- req
	}
}

func HTTPServer(addr <-chan string, errors chan<- error, requests chan<- *parts.HTTPRequest, shutdown <-chan context.Context) {
	const multiplicity = 1

	defer func() {
		close(requests)
		if errors != nil {
			close(errors)
		}

	}()
	const instanceNumber = 0
	svr := &http.Server{
		Handler: parts.HTTPHandler(requests),
		Addr:    <-addr,
	}
	var shutdone chan struct{}
	go func() {
		ctx := <-shutdown
		shutdone = make(chan struct{})
		svr.Shutdown(ctx)
		close(shutdone)
	}()
	err := svr.ListenAndServe()
	if errors != nil {
		errors <- err
	}
	if shutdone != nil {
		<-shutdone
	}
}

func Hello_World(requests <-chan *parts.HTTPRequest) {
	const multiplicity = 1

	const instanceNumber = 0
	for rw := range requests {
		rw.Write([]byte("Hello, HTTP!\n"))
		rw.Close()
	}
}

func Log_errors(errors <-chan error) {
	const multiplicity = 1

	const instanceNumber = 0
	for err := range errors {
		log.Printf("HTTP server: %v", err)
	}
}

func Metrics(requests <-chan *parts.HTTPRequest) {
	const multiplicity = 1

	const instanceNumber = 0

	h := promhttp.Handler()
	for r := range requests {
		h.ServeHTTP(r.ResponseWriter, r.Request)
		r.Close()
	}

}

func Press_Enter_to_shut_down(shutdown chan<- context.Context) {
	const multiplicity = 1

	const instanceNumber = 0
	fmt.Println("Press Enter to shut down.")
	var s string
	fmt.Scanln(&s)
	ctx, _ := context.WithTimeout(context.Background(), 5*time.Second)
	shutdown <- ctx
}

func Send_8765(addr chan<- string) {
	const multiplicity = 1

	const instanceNumber = 0
	addr <- ":8765"
}

func main() {

	channel0 := make(chan *parts.HTTPRequest, 0)
	channel1 := make(chan string, 0)
	channel2 := make(chan context.Context, 0)
	channel3 := make(chan error, 0)
	channel5 := make(chan *parts.HTTPRequest, 0)
	channel6 := make(chan *parts.HTTPRequest, 0)

	var wg sync.WaitGroup

	wg.Add(1)
	go func() {
		HTTPServeMux(channel5, channel0, channel6)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		HTTPServer(channel1, channel3, channel0, channel2)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Hello_World(channel6)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Log_errors(channel3)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Metrics(channel5)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Press_Enter_to_shut_down(channel2)
		wg.Done()
	}()

	wg.Add(1)
	go func() {
		Send_8765(channel1)
		wg.Done()
	}()

	// Wait for the various goroutines to finish.
	wg.Wait()
}
